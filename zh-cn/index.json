[{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 由于二叉树严重依赖输入的随机性，因此我们需要平衡二叉树（红黑二叉树）来实现能够自动调整树的结构以达到平衡。\n2-3查找树 在BST中，每个节点都是2-nodes, 也就是说节点只有一个值，其可以有2个字几点，因此在这里引入了3-nodes的概念，即一个节点有两个值，可以有三个子节点。可以想象成3-nodes就是两个2-nodes节点拼在一起。\n定义： 一个2-3 查找树中每个节点要不然空，要不然\n 是一个2-nodes: 该节点有一个值和左右两个子节点，左子树也是一个2-3查找树，并且其值都比该节点小，右子树也是一个2-3查找树，并且其值都比该节点大 或者是一个3-nodes: 该节点有两个值和三个子节点指针。左右子树根2-nodes一样，中间的子树的值介于该节点两个值之间  一个完全平衡的2-3 查找树就是指其所有的空节点到根的距离都相同。\n查找 2-3查找树中查找一个值根BST类似，都是递归的方式在对应的子树中去寻找，直至找到（命中）或者到达空节点（未命中）\n2-3查找树之所以能自动调整平衡，关键在于当往3-nodes中在加入一个值后其变成4-nodes, 而一个4-nodes可以拆成一个平衡的ts， 即中间的节点作为parent, 两边的节点作为左右自己点。因此对于2-3查找树，其插入，删除的核心都在2-nodes——\u0026gt;3-nodes-\u0026gt;4-nodes-\u0026gt;最后在分拆\n插入到2-nodes 当要要插入的节点是个2-nodes时，很简单，将其变为3-nodes即可 插入到3-nodes 当将一个值插入到3-nodes时，其变成4-nodes, 此时就要分拆。分拆后，树的高度+1 插入到父节点是2-nodes的3-nodes 由于插入到3-nodes会拆分，新生成的parent向上传递，而父节点是个2-nodes，因此父节点自然就组合成一个新的3-nodes 插入到父节点是3-nodes的3-nodes 同理，会向上两次传递。\n根节点的拆分 如果根节点本身已经是3-nodes, 在被向上拆分的子节点追加后会变成4-nodes, 此时根节点应该拆分，同时树的高度+1\n将临时的4-nodes拆分的过程是局部的，也就是说这种变换除了关联的节点及其链接，树的其他部分都不需要修改，因此每次变换我们只需要修改很小的部分，由此可说明当我们发现需要变换的节点时，这种变换时高效的。每次变换时，会将拆分出来的parent以及调整好结构的子树向外层传递。\n更重要的是，这种变换保持了树已经排好的顺序，并且保证树仍然是平衡的：也就是说从根到任何一个空节点的距离仍然是相等的。\n与BST比较，BST的增长是向下的，我们不断的添加子节点；平衡BST是从底部向上增长的，就是说我们在底部添加一个值，这个过程中如果有4-nodes形成就不断向上拆分，最终使root变成4-nodes,从而达到整个树高度+1\nProposition F: 查找和插入操作在N个元素构成的2-3查找树中需要访问最多lgN个节点。\n由此，分析2-3树与分析BST是不同的，因为2-3树的目的是为了确保最坏情况下的性能，而BST是分析其平均状况下的性能。在Symbol Table中由于我们没有办法去控制输入，所以分析最坏情况能够对性能做一个保证。\n红黑二叉树 为了实现2-3 tree，我们引入了红黑二叉树（red-black BST）,即用传统BST的Node结构加上一点额外信息来定义3-nodes：我们用red links 来将3-nodes中的两个元素链接起来，用black links来链接2-3tree中的每个节点。更具体的，我们将3-nodes用两个2-nodes用靠左的red link链接起来来表示。\n定义：红黑二叉树就是拥有Red links \u0026amp; Blank Links的BST并且满足如下限制：\n Red links靠左边 一个节点不能有两个Red links 整个树对于Black Links来说是完美平衡的：每个空链接到根都有相等的Blank Links数  颜色的表达 由于每个节点仅仅与其父节点相连接，我们在节点中增加一个是否是红色的属性，来表示其到其父节点的这个链接是否是Red links。\n旋转 在节点不断添加，合并，拆分的过程中，我们会碰到这些情况：Red Links并不靠左；一个节点有两个Red Links。 因此我们需要通过旋转来解决这些问题。旋转包括两种方式：左旋和右旋\n 左旋： 当Red link靠右时，我们需要通过左旋将其转到左边。具体思路如下：当R靠右时，说明子节点是比父节点大的，所以旋转后应该将子节点放在上面，而原来的父节点作为左边的子节点，同时相应的其他调整 右旋： 右旋同理，调整前子节点比父节点小，因此要右旋的话，我们应该将子节点放在上面，原来的父节点放在右下 在旋转时，除了挂在的节点要调整外，还有一些信息要调整： 无论左旋还是右旋，都是将父，子节点进行颠倒，原先都是子节点中color=Red, 调整后，其变成了父节点，因此color=parent.color, 而原来父节点的color旋转后应该变为Red. (即旋转后，我们仍然保持red link 不变。 只是由于旋转后交换了父子节点，所以color=red的保存也跟着改变了) 旋转后，子节点放在了父节点的位置上，因此其n值就是原来父节点的n值，而原来父节点需要通过size(x) = size(left) + size(right) + 1重新计算一遍  插入 当我们在红黑树中插入一个新元素，我们一定是插入一个有Red link节点，然后在根据需要调整。 例如一个只有根的树，我们在其左边插入一个节点，由于R靠左，不需要调整；如果插入在其右边，此时我们就需要做一个左旋。 如果我们插入的是一个3-nodes, 那么就可能有三种情况\n 新插入的值最大，那么就会形成一个中间元素有两个R子节点的情况——这种只需要要将其变成黑色即可 如果插入的值最小，就会形成中间元素的上下都是R的情况，此时我们要将其调整成正三角（上面的样子）——因此我们我们只要对上面的那根R做右旋，然后改变颜色即可 如果插入的值在中间，那就形成了中间的元素向上是R, 右下是R， 因此我们先最右下这个R进行左旋，变成2的样子，再继续操作即可  颜色的翻转 上面1的情况，我们需要做颜色的翻转，即将左右的两条红色变成黑色，Parent的设定成红色即可\n保持根的黑色 由于不断插入，最后颜色的翻转可能导致根的颜色是红色，所以我们需要插入元素后重新设定根是黑色的\n总结： 从上面1，2，3可以看出，操作是层层递进的。因此在实现中我们可以先检查右节点是否是R，进行左旋，然后检查左子节点及左子节点的子节点是否是红的，做右旋；最后做检查左右是否都是红的，做颜色翻转\n删除 对于删除，最重要的就是不能破坏其平衡性。如果以2-3树为思考，也就是说如果我们删除的地方是个2-nodes,删除后必然导致其下面的空链接长度改变，破坏了平衡。但是如果删除的位置是个3- nodes，那么即使我们删除掉这个元素，该位置仍然还有其他元素存在，我们只需要重新挂载一下子树就行，不会破坏平衡性。所以删除的核心就是如果能够确保我们在仍和情况下都是删除的3-nodes.\n红黑二叉树是通过插入时的拆分来保持平衡，那么在删除时我们就需要先做合并，将2-node合并成3-nodes或者4-node,删除完成后，再将多余的4-nodes重新拆分\n如何合并：\n 如果是左右都是2-nodes, 那么不管parent是2-nodes还是3- nodes，我们都可以从parent找一个节点出来，和这两个子节点构成4- nodes，只要将左右link变红即可。 如果左右子节点一个是2- nodes， 一个是3- nodes，那么对于要扩展的那一变，我们只需要将parent拿下来和这个2-nodes拼成一个3- nodes，而从另一个3-nodes中取一个节点放到原来parent的位置上  删除最小值 有了上面合并的思路，我们要删除最小值，就意味着我们沿着最左边的一条路径不断做合并到底部，然后删除最小元素，进而原路返回，将路上碰到的4-nodes重新拆分掉\n 如果当前节点的左孩子不是2- nodes，那么什么都不用做，继续向坐下走 如果左孩子是个2- nodes，并且其直接兄弟是个3- nodes，那么从3-nodes中移动一个元素，将2-node变成3-nodes 如果左孩子及其直接兄弟都是2- nodes，那么将这两个孩子以及parent中最小的元素一起构成一个4-nodes,此时parent将从4-nodes变成3-nodes或者从3-nodes变成2- nodes。  删除任意的值 有了上面删除最小值为基础，当我们删除任意值时，同样的道理，如果最终删除的位置在底部，那么我们直接删除就可以了，如果不是底部，此时我们将这个元素和比他大的最近的元素（即右子树的最小值）做交换。于是我们将问题转化为删除右子树的最小值。\n分析 Proposition G: 由N个元素组成的红黑二叉树其高度不高于2lgN\nProposition H：由N个元素组成的红黑二叉树从其根到节点的距离大约是～1.00lgN\n由此可见，红黑二叉树平均下来大约比BST快40%左右\n","date":"2022-01-27","img":"","permalink":"/zh-cn/guide/algo-search-balanced-bst/","series":[],"tags":["search","bst"],"title":"查找-平衡二叉树"},{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 对于查找，第一个直觉就是先排序，然后再从中找到需要的对象。那么为什么要将查找和排序分开来呢，一个重要的原因是对于查找我们需要一种结构能够保证我们既找的快，有能够不因为插入/删除时耗费大量的时间。\n对于符号表(symbol-table)来说，二叉树(Binary Search Trea \u0026ndash; BST)是一种理想的结构。\n定义 二叉查询树是一种二叉树，其每个节点包含有一个可比较的（Comparable）键值，并且规定任何一个节点的值都比其左子树的值大，比其右子树的值小。\n1private class Node { 2 private final Key key; 3 private Value value; 4 private Node left, right; 5 private int n; 6 7 public Node(Key key, Value value, int n) { 8 this.key = key; 9 this.value = value; 10 this.n = n; 11 } 12 } 要注意的一点： n 记录了当前节点下子节点的数量(包含自身), 因此对于节点x, 其size的公式为\n1size(x) = size(x.left) + size(x.right) + 1; n的用处在于我们可以通过x.left.n知道当前节点在整个序列中的位置，这对于实现rank等方法非常有用。\n搜索 二叉查询树的搜索是很直观的，通过递归的方式很好理解：将要查找的key和当前节点的key比较，如果小，则继续在左子树中查询，如果大，则在右子树中查询，如果相等则命中。如果左/右子树为空，则未命中。 如果在整个树中包含某个值，则称为命中（search hit）, 否则叫未命中(search miss)\n插入 插入同样很简单，从根开始不断向下走（小就走左边，大就走右边），知道走到底部，将节点插入到底部节点的下面就可以了。 这里要注意一下递归： 跟搜索一样，插入也同样使用了递归。我们不断使用递归走到目标所在之处，对于搜索来说，此时我们返回结果，每层递归将传递过来的结果返回出去。但是插入不一样，我们需要更新我们的子树，同时更新我们的节点数n。\n分析 二叉树的查找时间依赖于树的形状，也就是说依赖于输入的顺序。\n当二叉树是完全平衡的，那么其高度大约为～lgN, 在最坏的情况下，其高度为N, 通常情况下，树的形状还是比较接近平衡的。 在许多应用中，我们认为其输入都是随机的，那么分析BST就近似于我们分析QuickSort. 树的根就如同QS中的第一次分段，由此我们得出如下推论：\nProposition C: 对于随机的N个输入构造的BST, 查找命中平均大约需要～2lnN(也就是1.39lgN)次比较。 Proposition D: 插入或者查找未命中对于随机的N个输入构造的BST平均大约需要～2lnN(也就是1.39lgN)次比较\n跟顺序有关的其他方法以及删除 BST最重要的特征就是就是允许我们按键值的顺序保存，因此也就提供许多需要基于顺序的方法\n最大/最小值 Floor /Ceiling 对于Floor，我们递归的比较key与当前节点的键值，如果小于节点，那么在左子树中继续查找，如果相当，那就是这个节点，如果比节点大，那么我们就需要去右子树找，此时存在一种情况，如果右子树中找不到比key小的值，那这个节点就是返回值 Ceiling类似\nselect select 就是查找指定位置的节点。 此时我们就需要利用节点中n的信息。 由于一个节点所处的位置等于其左子树的n + 1, 所以我们将指定的值与左子树的n值比较，如果小，那么继续在左子树的查找，如果大，那么我们转而查找右子树，由于左边已经有n个元素了，所以其实我们在右子树中查找k -n - 1位置的元素。以此类推\nrank rank 查找元素的排名，仍然是递归的方式，如果key比当前节点小，那么在左子树去查找，如果相当，那么排名就等于小size(x.left), 如果大，那么其排名就是size(x.left) + 其在右子树的排名 + 1 注意一点，rank是从0开始的，而我们的节点的n默认是1（包含自己），所以一个节点的rank就是x.left\n删除最大/最小节点 删除最小节点是为删除任意节点做准备。 要删除最小节点思路很简单，不断在左子树中找到左子树为空的节点即可。删除时，用该节点的右子树来代替该节点。\n删除任意节点 删除节点仍然是通过递归先查找该节点。 删除时思路为用该节点右子树的最小节点来代替该节点，所以我们找到其右子树最小节点后问题转化为删除右子树的最小节点。\nProposition E: 对于BST, 在最坏的情况下，任何操作所需要的时间跟树的高度成正比。\n总结 BST实现比较容易，同时如果输入时比较随机的话能够提供很好的查询和插入效率。同时BST也提供了快速的rank, select, delete ,range query等方法，因此也受到欢迎。同时也要强调，其性能深受输入顺序的影响，在比较坏的情况下可能无法达成预期。 与快速排序比较，我们可以在快速排序前对数组先做一次随机操作，但是对于symbol table, 我们没办法这样做。\n因此我们需要引入平衡二叉树。 ","date":"2022-01-26","img":"","permalink":"/zh-cn/guide/algo-search-bst/","series":[],"tags":["search","bst"],"title":"查找-二叉树"},{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 快排由于实现起来简单，对各种类型的数据都有效，比大多数排序算法都效率高，因此可能是使用最广泛的排序算法。快排的两个显著特征：直接在数组上进行操作，不需要额外的内存；执行时间接近于NlgN, 同时结合这两点是其他算法（插入排序，选择排序，合并排序等）所不具备的。\n并且由于快排使用更短的内循环次数，因此在实际使用中效率可能更好。 快排的缺点在于在实现中有许多细节需要考虑到，否则可能大大的降低效率。\n实现 快排使用的是分治的思路，通过将数组分割成两个部分，然后独立的对两部分进行排序。\n","date":"2022-01-13","img":"","permalink":"/zh-cn/guide/algo-sort-quicksort/","series":[],"tags":["sort"],"title":"排序-快速排序"},{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 实现 这个算法的基本思想是合并：将两个排好序的数组合并成一个数组。 因此合并排序简单来说就是将一个数组分成两半，递归的将两半各自排好序，再将其合并成一个大的数组。 合并排序最重要的一个特点就是能保证执行时间是NlogN。缺点是需要跟N成比例的额外的空间。\n要实现合并排序，最直接的就是实现将两个数组合并成一个数组的方法：额外创建一个数组，从两个数组中不断取最小的对象放到这个存放数组中。 当要对一个大数组进行合并排序时，我们需要做大量的合并操作，因此每次创建新数组去保存结果也是一笔不小的开销。因此，如果能够直接在数组上操作，可以大大减小开销————想起来很简单，实现起来很复杂，特别是跟用额外数组做合并的方式比较起来的话。\n1public static void merge(Comparable[] a, int lo, int mid, int hi) { 2 // Merge a[lo..mid] with a[mid+1..hi]. 3 int i = lo, j = mid+1; 4 for (int k = lo; k \u0026lt;= hi; k++) // Copy a[lo..hi] to aux[lo..hi]. 5 aux[k] = a[k]; 6 7 for (int k = lo; k \u0026lt;= hi; k++) // Merge back to a[lo..hi]. 8 if (i \u0026gt; mid) a[k] = aux[j++]; 9 else if (j \u0026gt; hi ) a[k] = aux[i++]; 10 else if (less(aux[j], aux[i])) a[k] = aux[j++]; 11 else a[k] = aux[i++]; 12} 自顶而下的合并 上面的实现是著名的分治的例子：如果对两个子数组排序，那么将两个数组合并后就相当于对整个数组排序了。 要理解合并排序，需要理解调用的过程。假设排序a[0\u0026hellip;15], 需要调用a[0\u0026hellip;7] -\u0026gt;a[0\u0026hellip;3] -\u0026gt;a[0\u0026hellip;1] 从而调用merge(0, 1), 然后继续调用a[2\u0026hellip;3] 调用merge(2,3)如此反复。 我们可以看出，sort通过递归，提供了一组调用merge的顺序组，排序是通过不断的merge来实现的，而sort则指导什么时候对什么数组进行merge。\nProposition F: 对于长度为N的数组，自顶而下的合并排序使用1/2NlgN ～ NlgN之间次数的比较 证明：假设C(N)代表对长度为N的数组排序所需要的比较次数，我们有C(0)=C(1)=0。对于N\u0026gt;0,我们按照递归的思路，可以得到C(N)\u0026lt;= C(N/2) + C(N/2) + N, 其中第一个C(N/2)代表做半部排序的次数，第二个代表右半部的次数。 同时还有C(N) \u0026gt;= C(N/2) + C(N/2) + N/2, 这里N/2代表左半部（我们至少要比较一半） 如果N = 2n, 那么左半部和右半部都是2n-1。 由此我们推导出 C(2n) = 2C(2n-1) + 2n(后面略)\n换一种方式来理解Proposition F\n优化 对上面算法可以继续优化\n 由于对小数组，插入排序是高效的，因此我们当递归到小数组（比如长度小于15）时，我们可以用插入排序来替代 在合并两个数组前先检查左半部的最后一个对象是否刚好小于等于右半部的第一个对象，如果是，我们就不用挨个比较了 消除额外的数组复制。 我们合并时，要不然先将对象复制到一个数组，然后合并回来，要不然将对象合并到一个数组，再复制回来。因此如果我们能够在一次合并时，将一个数组作为输入，一个作为输出，下次合并时将输出的数组作为输入，就能够减少一次复制  注意：以上的优化不是必须的，因为优化往往伴随着代码的复杂。解决一个问题时，我们应该首先选用最简单的办法，当遇到性能瓶颈时再考虑优化他。\n自下而上的合并 对于分治的思想，由于最终都是将大问题逐渐分解成最小的问题，所以我们可以自下而上，即现两个两个合并，然后四个四个合并，直到整个数组的合并。\n对于长度为2的幂的数组，自顶而下 和 自下而上效率时相同的，只是顺序相反， 但是其他长度则可能有效率上的差距\n排序算法的复杂度 学习合并算法的一个重要原因是因为通过他我们可以推导出排序算法的复杂度，即排序算法的极限。 研究算法的复杂度就是建立一个算法的计算模型。 对于以比较为基础的排序算法（插入，选择，合并排序都是此类， 还有不用通过比较来排序的算法），关键制约是：\n 可以处理任意多的输入 我们除了在比较时能够知道两个对象的key之外得不到其他任何key的信息 Prop I. 没有以比较为基础的排序算法可以做到比较的次数少于lg(N!) ~ NlgN  ","date":"2022-01-12","img":"","permalink":"/zh-cn/guide/algo-sort-mergesort/","series":[],"tags":["sort"],"title":"排序-合并排序"},{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 前言 排序就是将对象按照一定的顺序排列。据统计，大约有30%的运算都是排序。 有三个理由让我们需要研究排序：\n 研究排序算法是我们研究其他算法效率的基础 在研究过程中使用的技巧对于其他问题也是有效的 我们经常以排序作为解决其他问题的第一步  更重要的是排序算法本身是优雅，经典和高效的\n着手点  我们首先要定义什么是排序 验证。 我们需要验证我们算法的正确性。 即使我们已经测试过，我们也应该为每个算法提供一个检验函数isSorted() 执行时间。 我们首先由一些不同的排序算法得到每个算法的基本操作数量（例如比较，交换，对数组的读写等），然后由这些数据作为基础提出一个算法效率的假设，并且提供一个可以用来验证这个假设正确与否的工具， 内存使用。算法的内存使用情况和执行时间同样重要。排序算法通常可以分为两类：一种直接排序，基本不使用或者只用少量的栈； 另一种需要使用额外的内存来保存排好序的结果 数据类型：我们的排序代码对于任何实现了Comparable\u0026lt;T\u0026gt;的对象都是有效的  选择排序 这个排序很简单： 首先，找到最小的对象将其放在第一位，然后依次找到最小的放在第二，第三位，直到这个数组排好序。这个算法叫选择排序是因为它通过不断在剩余的对象中寻找最小的元素。\nProposition A: 算法使用~N2/2次比较和N次交换\n算法的特点：\n 执行时间对于输入的数据不敏感。在一次循环中查找最小元素对于下次循环没有什么帮助，因此即使是一个排好序的数组仍要花费相同的时间进行排序。这是个极大的劣势 数据的移动很少，最多交换N次，相对于数组长度是线性的。其他算法都大大多于这个数量  插入排序 插入排序类似于我们对扑克牌的排序，每次将一张牌插入已经排好序的牌的对应的位置之中。具体实现中，我们需要通过将所有大的元素向右移动一个位置来为当前的元素空出位置。 在插入排序里，当前位置左边的元素都是已经排好序的，但是他们的位置不一定是最终的位置，因为继续排序的过程中可能会为更小的元素腾位置。但是当到达最后的位置时，整个数组是排好序的。 与选择排序不同，插入排序的执行时间跟数组最初的顺序有关。如果数组本身已经排好序，那么其执行会很快\nProposition B: 执行时间： ～N2/4次比较和～N2/4次交换，最坏的情况下～N2/2次比较和～N2/2次交换\n 想象一下，最坏的情况，就是一个选择排序，因为每次都要将该元素放到最左边， 平均下来，如果是比较一半，那么就是～N2/4\n  对于已经排好序的数组，插入排序很适合  更普遍的，我们考虑部分排序的数组：假设我们定义一个颠倒是指数组中一对元素顺序错误，例如E X A M P L E有11对颠倒：E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E。如果数组中这样的颠倒的个数少于数组长度的常数倍，我们就说这个数组是部分排序的。 常见的部分排序的数组的例子：\n 一个数组中，每个元素离正确的位置都不太远 一个小的数组在一个大的已经排好序的数组之后 一个数组中只有几个元素位置不正确  插入排序对于上述部分排序的数组是高效的，而选择排序则不。事实上，对于已经部分排序的数组，插入排序比其他排序算法更高效。\nProposition C: 插入排序中交换的次数等于颠倒的数量，比较的次数最少是颠倒的数量，最多是颠倒的数量加上数组的长度减去1.\n总结：插入排序对于部分排序数组和小数组是极好的算法，不仅仅是因为这两类数组经常碰到，还因为对于许多高级算法，这两类数组通常会作为中间结果出现。\n比较两种排序算法 要比较算法，我们需要遵从下面的步骤\n 实现算法 分析每个算法的基本属性（Proposition A, B, C） 形成算法性能比较的推论 (Proposition D) 执行测试数据来验证这个推论 (SortCompare)  具体来说：\n实现算法： 略\n分析 为输入对象建立合适的model. 对于排序，我们假设数组是随机的，并且key是不重复的。 因此对于key会重复的应用需要慎重对待\n推论 Property D: 选择排序和插入排序对于随机的，key不同的数组的执行时间是数组长度的平方和一个小的，常数因子的积\n验证： 我们实现一个SortCompare类，这个类很简单，就是输入生成随机数组的长度(N)和重复次数(T)，计算不同算法的话费时间总和进而比较\n1public class SortCompare { 2 3 public static double time(String alg, Double[] a) { /* See text. */ } 4 5 public static double timeRandomInput(String alg, int N, int T) { // Use alg to sort T random arrays of length N. 6 double total = 0.0; 7 Double[] a = new Double[N]; 8 for (int t = 0; t \u0026lt; T; t++) { 9 // Perform one experiment (generate and sort an array). 10 for (int i = 0; i \u0026lt; N; i++) 11 a[i] = StdRandom.uniform(); 12 total += time(alg, a); 13 14 } 15 return total; 16 } 17 18 public static void main(String[] args) { 19 String alg1 = args[0]; 20 String alg2 = args[1]; 21 int N = Integer.parseInt(args[2]); 22 int T = Integer.parseInt(args[3]); 23 double t1 = timeRandomInput(alg1, N, T); // total for alg1 24 double t2 = timeRandomInput(alg2, N, T); // total for alg2 25 StdOut.printf(\u0026#34;For %d random Doubles\\n %s is\u0026#34;, N, alg1); 26 StdOut.printf(\u0026#34; %.1f times faster than %s\\n\u0026#34;, t2/t1, alg2); 27 } 28} 贝壳排序（ShellSort） 插入排序对于大的，无序的数组排序之所以慢是因为每次只能对相邻的元素进行交换，一次只能移动一位。例如如果最小的元素排在最后，则需要移动n-1次。贝壳排序是对插入排序的扩展。通过允许对间隔较远的元素进行交换，形成多个部分排序的数组，最后用插入排序进行有效的处理。\n具体思路：将数组以间隔h长度分成多个子数组，对每个子数组进行排序。例如以间隔4为单位，那么0，4，8。。。为一组，1，5，9\u0026hellip;.为另一组。这个方式的优点在于我们可以将交换的间隔从插入排序的1位变成了h位。同时每个子数组的长度变小了，当h足够大时，就变成了对小数组的排序\u0026ndash;插入排序对于小数组是有效率的。 然后我们逐渐减小h的值，在这个过程中我们是不断的对部分排序的数组进行排序，因此也能保证效率。当h=1时即完成了排序。\n1public void sort(T[] a) { 2 int n = a.length; 3 int h = 1; 4 while (h \u0026lt; n / 3) h = 3 * h + 1; 5 while (h \u0026gt;= 1) { 6 for (int i = h; i \u0026lt; n; i++) { 7 for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; less(a[j], a[j-h]); j -= h) { 8 exch(a, j, j-h); 9 } 10 } 11 h = h / 3; 12 } 13 } 这里有几个值得注意的点：\n 代码中按照3倍进行分割，也就是说1， 4， 13， 40\u0026hellip; 假设长度为16的数组，第一次h=13, 实际上就是对数组的首尾进行了排序。13\u0026lt;-\u0026gt;0, 14\u0026lt;-\u0026gt;1,15\u0026lt;-\u0026gt;2。 第二次循环，h=4,于是从index=4开始到末尾，间隔4个排序。依次类推 假设按照4倍分割，则为1，5，21，。。。，对于大数组，比如10000个，跟3区别不大，甚至按照5倍分割区别不大，（执行时间接近）,以下是按照不同倍数分割的执行时间  1shell----split = 2, to 1000000 random array, spent 816 millis 2shell----split = 3, to 1000000 random array, spent 712 millis 3shell----split = 4, to 1000000 random array, spent 738 millis 4shell----split = 5, to 1000000 random array, spent 704 millis 5shell----split = 6, to 1000000 random array, spent 718 millis 6shell----split = 7, to 1000000 random array, spent 768 millis 7shell----split = 8, to 1000000 random array, spent 784 millis 8shell----split = 9, to 1000000 random array, spent 841 millis 9shell----split = 10, to 1000000 random array, spent 827 millis 10shell----split = 11, to 1000000 random array, spent 825 millis 11shell----split = 12, to 1000000 random array, spent 884 millis 12shell----split = 13, to 1000000 random array, spent 902 millis 13shell----split = 14, to 1000000 random array, spent 922 millis 14shell----split = 15, to 1000000 random array, spent 951 millis 15shell----split = 16, to 1000000 random array, spent 1021 millis 16shell----split = 17, to 1000000 random array, spent 1022 millis 17shell----split = 18, to 1000000 random array, spent 1116 millis 18shell----split = 19, to 1000000 random array, spent 1145 millis 从上面可以看出，当split比较小时，我们最开始循环的子数组数量比较少，速度比较快。 想想对于16长度，3倍分割，第一次从13开始，子数组长度是2， 如果是4倍分割，则从5开始，那么排在10以后的需要排3个， 由此可见， 小数组和部分排序的数组是影响插入排序效率的关键 3. 贝壳排序的核心就是对于h,用插入排序来独立的处理每个h 序列。注意每次h是开头，所以要求j\u0026gt; h\n如何决定分割量的大小？不同的值倍研究过，但还没有找到最佳的值，因此按例子中3倍来是可行的\n执行时间 贝壳排序的实行时间不在是N2的倍数。 例如上面算法最坏情况下是N3/2\n简单的修改算法就可以打破N2的限制，这就是算法研究的有趣之处\nProperty E : 如果以1，4，13，40，121，364。。。为增量，贝壳算法的比较次数不超过增量的N倍的一小部分\n总结 贝壳算法代码简单，代码量少。对于中大型数组效率比较高，同时不额外使用内存\n","date":"2022-01-10","img":"","permalink":"/zh-cn/guide/algo-sort-elementory/","series":[],"tags":["sort"],"title":"排序-基本排序"},{"categories":["工具"],"content":"一直觉得自己总该写些什么，特别是在网上浏览别人的文档时，总会不自觉的被各种分享所吸引。 模糊中记得一句话，作为一个IT从业人员，重要的一点就是在网上留下自己的印记。好吧， 是否留下印记无所谓， 不过想想将来有一天翻看这些文档，犹如自己翻看曾经的日记，感觉也是挺美妙的。\n大概两年前就打算这样弄过， 但是懒总是阻碍人类前进的一大阻力。 在github上开通了git page, 写下自己的大名之后，时间就静止了，一晃两年过去。\n继续两年未竟之事业 —— 大约等于从头开始。\n选择Host 当然是选择免费的，github提供了page。 如果是用码云的，似乎也有相应的page,道理类似。\n所谓git page, 是github为每个人保留了一个特殊的repo, 就是你的用户名+ github.io. 创建好这个repo, 例如我的 yaoyuqi.github.io. 在里面更新静态html, 就可以访问：如http://yaoyuqi.github.io\n建站方式 由于是静态页面，所以我们需要一个方案来将我们的文档有组织有结构的生成html。\n手写是不可能的，这辈子都不可能的。\n翻了翻，大约流行的是这三个jekyll, hexo, hugo. 这三个都是比较完整的框架，内置server, 也就是说可以运行后在本地通过浏览器访问本地的网页，同样也支持各种插件安装。最后生成需要上传的页面\n简单比较    方案 语言 特点     jekyll Ruby 应该很老牌，github默认建git page时就推荐用这个。 应该各种插件之类很全。 编译速度慢一点   hexo Node 用node搞的，好像是台湾的达人弄的，所以中文文档丰富   hugo go 编译速度快。 看了看文档页，目测文档数量是hexo的两倍 —— 复杂    我本打算选用jekyll, 可以按照官方文档安装后运行报错， 搜了一下，应该是mac的m1芯片在调用sass的一个解析器时出错。对于这种错误，如果没有很快速的搜到解决方案，那就放弃，折腾起来太费时间\n——所以Jekylly被我放弃了。\n于是我拥抱了hugo\nhugo构建 很简单\n 将repo clone下来 按照hugo文档安装。 创建一个页面，运行hugo server -D ，即可在本地查看预览 推送上去就能访问了  突然发现我的这个guide很水。。。 😄😄😄😄\n其实最后一点不准确，推送上去是看不到刚才创建的文章的，甚至连网页都打不开，因为整个repo都变成了包含hugo的一整套库，git page是不认识的，记得吗，人家只认静态页面。\n我们推送的应该是hugo编译好的结果的文件。例如xxx.html/ xxx.js/ xxxx.cs\n这些文件在哪里呢？ 其实在public目录下，运行hugo 就会生成，因此我们要上传的其实是这个public文件夹。\n更进一步 参考hugo的部署文档，发现里面指导使用github的actions来发布。 关于github的actions, 可以参考这篇文章 简单的说，这个actions就类似jenkins, github提供了一些虚拟机环境，你可以通过配置脚本在执行一些操作。\n以我们发布文章来说，我们需要当提交整个repo后，github能够帮我们编译生成静态页面，然后将其放到我们git page的页面里。 这里再说一下，github为这类提供了一个专用分支，gh-page, 也就是说按照部署文档来最后我们可以看到repo多了一个gh-page分支，里面就是public的内容。\n使用github的actions很单间，就是在repo下创建一个.workflows目录，再放一个xx.yml，这个xx.yml就是配置文件。每次提交，github就会触发这个action\n万事具备，于是这篇文章就诞生了。\n","date":"2021-12-11","img":"","permalink":"/zh-cn/guide/use-hugo-with-github-page/","series":[],"tags":[""],"title":"Use Hugo With Github Page"},{"categories":null,"content":"你好，世界。\n这是一个新的开始，我相信明天总是很美好的。\n","date":"2021-12-09","img":"","permalink":"/zh-cn/posts/my-first-post/","series":null,"tags":null,"title":"My First Post"},{"categories":null,"content":" Tian Yuan\u0026rsquo;s husband and Pingping \u0026amp; Anan\u0026rsquo;s father. More than 10 years in software developing. Mainly in Java, Php, Js Plantyful experience in Lavarel, Spring, React. Others including Javafx, Android  ","date":"2021-12-09","img":"","permalink":"/zh-cn/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/zh-cn/contact/","series":null,"tags":null,"title":"Contact Me"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/zh-cn/offline/","series":null,"tags":null,"title":"Offline"}]