[{"categories":["算法"],"content":" 本文内容来自 Algorithhms 4th Edition\n 前言 排序就是将对象按照一定的顺序排列。据统计，大约有30%的运算都是排序。 有三个理由让我们需要研究排序：\n 研究排序算法是我们研究其他算法效率的基础 在研究过程中使用的技巧对于其他问题也是有效的 我们经常以排序作为解决其他问题的第一步  更重要的是排序算法本身是优雅，经典和高效的\n着手点  我们首先要定义什么是排序 验证。 我们需要验证我们算法的正确性。 即使我们已经测试过，我们也应该为每个算法提供一个检验函数isSorted() 执行时间。 我们首先由一些不同的排序算法得到每个算法的基本操作数量（例如比较，交换，对数组的读写等），然后由这些数据作为基础提出一个算法效率的假设，并且提供一个可以用来验证这个假设正确与否的工具， 内存使用。算法的内存使用情况和执行时间同样重要。排序算法通常可以分为两类：一种直接排序，基本不使用或者只用少量的栈； 另一种需要使用额外的内存来保存排好序的结果 数据类型：我们的排序代码对于任何实现了Comparable\u0026lt;T\u0026gt;的对象都是有效的  选择排序 这个排序很简单： 首先，找到最小的对象将其放在第一位，然后依次找到最小的放在第二，第三位，直到这个数组排好序。这个算法叫选择排序是因为它通过不断在剩余的对象中寻找最小的元素。\nProposition A: 算法使用~N2/2次比较和N次交换\n算法的特点：\n 执行时间对于输入的数据不敏感。在一次循环中查找最小元素对于下次循环没有什么帮助，因此即使是一个排好序的数组仍要花费相同的时间进行排序。这是个极大的劣势 数据的移动很少，最多交换N次，相对于数组长度是线性的。其他算法都大大多于这个数量  插入排序 插入排序类似于我们对扑克牌的排序，每次将一张牌插入已经排好序的牌的对应的位置之中。具体实现中，我们需要通过将所有大的元素向右移动一个位置来为当前的元素空出位置。 在插入排序里，当前位置左边的元素都是已经排好序的，但是他们的位置不一定是最终的位置，因为继续排序的过程中可能会为更小的元素腾位置。但是当到达最后的位置时，整个数组是排好序的。 与选择排序不同，插入排序的执行时间跟数组最初的顺序有关。如果数组本身已经排好序，那么其执行会很快\nProposition B: 执行时间： ～N2/4次比较和～N2/4次交换，最坏的情况下～N2/2次比较和～N2/2次交换\n 想象一下，最坏的情况，就是一个选择排序，因为每次都要将该元素放到最左边， 平均下来，如果是比较一半，那么就是～N2/4\n  对于已经排好序的数组，插入排序很适合  更普遍的，我们考虑部分排序的数组：假设我们定义一个颠倒是指数组中一对元素顺序错误，例如E X A M P L E有11对颠倒：E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E。如果数组中这样的颠倒的个数少于数组长度的常数倍，我们就说这个数组是部分排序的。 常见的部分排序的数组的例子：\n 一个数组中，每个元素离正确的位置都不太远 一个小的数组在一个大的已经排好序的数组之后 一个数组中只有几个元素位置不正确  插入排序对于上述部分排序的数组是高效的，而选择排序则不。事实上，对于已经部分排序的数组，插入排序比其他排序算法更高效。\nProposition C: 插入排序中交换的次数等于颠倒的数量，比较的次数最少是颠倒的数量，最多是颠倒的数量加上数组的长度减去1.\n总结：插入排序对于部分排序数组和小数组是极好的算法，不仅仅是因为这两类数组经常碰到，还因为对于许多高级算法，这两类数组通常会作为中间结果出现。\n比较两种排序算法 要比较算法，我们需要遵从下面的步骤\n 实现算法 分析每个算法的基本属性（Proposition A, B, C） 形成算法性能比较的推论 (Proposition D) 执行测试数据来验证这个推论 (SortCompare)  具体来说：\n实现算法： 略\n分析 为输入对象建立合适的model. 对于排序，我们假设数组是随机的，并且key是不重复的。 因此对于key会重复的应用需要慎重对待\n推论 Property D: 选择排序和插入排序对于随机的，key不同的数组的执行时间是数组长度的平方和一个小的，常数因子的积\n验证： 我们实现一个SortCompare类，这个类很简单，就是输入生成随机数组的长度(N)和重复次数(T)，计算不同算法的话费时间总和进而比较\n1public class SortCompare { 2 3 public static double time(String alg, Double[] a) { /* See text. */ } 4 5 public static double timeRandomInput(String alg, int N, int T) { // Use alg to sort T random arrays of length N. 6 double total = 0.0; 7 Double[] a = new Double[N]; 8 for (int t = 0; t \u0026lt; T; t++) { 9 // Perform one experiment (generate and sort an array). 10 for (int i = 0; i \u0026lt; N; i++) 11 a[i] = StdRandom.uniform(); 12 total += time(alg, a); 13 14 } 15 return total; 16 } 17 18 public static void main(String[] args) { 19 String alg1 = args[0]; 20 String alg2 = args[1]; 21 int N = Integer.parseInt(args[2]); 22 int T = Integer.parseInt(args[3]); 23 double t1 = timeRandomInput(alg1, N, T); // total for alg1 24 double t2 = timeRandomInput(alg2, N, T); // total for alg2 25 StdOut.printf(\u0026#34;For %d random Doubles\\n %s is\u0026#34;, N, alg1); 26 StdOut.printf(\u0026#34; %.1f times faster than %s\\n\u0026#34;, t2/t1, alg2); 27 } 28} 贝壳排序（ShellSort） 插入排序对于大的，无序的数组排序之所以慢是因为每次只能对相邻的元素进行交换，一次只能移动一位。例如如果最小的元素排在最后，则需要移动n-1次。贝壳排序是对插入排序的扩展。通过允许对间隔较远的元素进行交换，形成多个部分排序的数组，最后用插入排序进行有效的处理。\n具体思路：将数组以间隔h长度分成多个子数组，对每个子数组进行排序。例如以间隔4为单位，那么0，4，8。。。为一组，1，5，9\u0026hellip;.为另一组。这个方式的优点在于我们可以将交换的间隔从插入排序的1位变成了h位。同时每个子数组的长度变小了，当h足够大时，就变成了对小数组的排序\u0026ndash;插入排序对于小数组是有效率的。 然后我们逐渐减小h的值，在这个过程中我们是不断的对部分排序的数组进行排序，因此也能保证效率。当h=1时即完成了排序。\n1public void sort(T[] a) { 2 int n = a.length; 3 int h = 1; 4 while (h \u0026lt; n / 3) h = 3 * h + 1; 5 while (h \u0026gt;= 1) { 6 for (int i = h; i \u0026lt; n; i++) { 7 for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; less(a[j], a[j-h]); j -= h) { 8 exch(a, j, j-h); 9 } 10 } 11 h = h / 3; 12 } 13 } 这里有几个值得注意的点：\n 代码中按照3倍进行分割，也就是说1， 4， 13， 40\u0026hellip; 假设长度为16的数组，第一次h=13, 实际上就是对数组的首尾进行了排序。13\u0026lt;-\u0026gt;0, 14\u0026lt;-\u0026gt;1,15\u0026lt;-\u0026gt;2。 第二次循环，h=4,于是从index=4开始到末尾，间隔4个排序。依次类推 假设按照4倍分割，则为1，5，21，。。。，对于大数组，比如10000个，跟3区别不大，甚至按照5倍分割区别不大，（执行时间接近）,以下是按照不同倍数分割的执行时间  1shell----split = 2, to 1000000 random array, spent 816 millis 2shell----split = 3, to 1000000 random array, spent 712 millis 3shell----split = 4, to 1000000 random array, spent 738 millis 4shell----split = 5, to 1000000 random array, spent 704 millis 5shell----split = 6, to 1000000 random array, spent 718 millis 6shell----split = 7, to 1000000 random array, spent 768 millis 7shell----split = 8, to 1000000 random array, spent 784 millis 8shell----split = 9, to 1000000 random array, spent 841 millis 9shell----split = 10, to 1000000 random array, spent 827 millis 10shell----split = 11, to 1000000 random array, spent 825 millis 11shell----split = 12, to 1000000 random array, spent 884 millis 12shell----split = 13, to 1000000 random array, spent 902 millis 13shell----split = 14, to 1000000 random array, spent 922 millis 14shell----split = 15, to 1000000 random array, spent 951 millis 15shell----split = 16, to 1000000 random array, spent 1021 millis 16shell----split = 17, to 1000000 random array, spent 1022 millis 17shell----split = 18, to 1000000 random array, spent 1116 millis 18shell----split = 19, to 1000000 random array, spent 1145 millis 从上面可以看出，当split比较小时，我们最开始循环的子数组数量比较少，速度比较快。 想想对于16长度，3倍分割，第一次从13开始，子数组长度是2， 如果是4倍分割，则从5开始，那么排在10以后的需要排3个， 由此可见， 小数组和部分排序的数组是影响插入排序效率的关键 3. 贝壳排序的核心就是对于h,用插入排序来独立的处理每个h 序列。注意每次h是开头，所以要求j\u0026gt; h\n如何决定分割量的大小？不同的值倍研究过，但还没有找到最佳的值，因此按例子中3倍来是可行的\n执行时间 贝壳排序的实行时间不在是N2的倍数。 例如上面算法最坏情况下是N3/2\n简单的修改算法就可以打破N2的限制，这就是算法研究的有趣之处\nProperty E : 如果以1，4，13，40，121，364。。。为增量，贝壳算法的比较次数不超过增量的N倍的一小部分\n总结 贝壳算法代码简单，代码量少。对于中大型数组效率比较高，同时不额外使用内存\n","date":"2022-01-10","img":"","permalink":"/zh-cn/guide/algo-sort-1/","series":[],"tags":["sorting"],"title":"排序-基本排序"},{"categories":["工具"],"content":"一直觉得自己总该写些什么，特别是在网上浏览别人的文档时，总会不自觉的被各种分享所吸引。 模糊中记得一句话，作为一个IT从业人员，重要的一点就是在网上留下自己的印记。好吧， 是否留下印记无所谓， 不过想想将来有一天翻看这些文档，犹如自己翻看曾经的日记，感觉也是挺美妙的。\n大概两年前就打算这样弄过， 但是懒总是阻碍人类前进的一大阻力。 在github上开通了git page, 写下自己的大名之后，时间就静止了，一晃两年过去。\n继续两年未竟之事业 —— 大约等于从头开始。\n选择Host 当然是选择免费的，github提供了page。 如果是用码云的，似乎也有相应的page,道理类似。\n所谓git page, 是github为每个人保留了一个特殊的repo, 就是你的用户名+ github.io. 创建好这个repo, 例如我的 yaoyuqi.github.io. 在里面更新静态html, 就可以访问：如http://yaoyuqi.github.io\n建站方式 由于是静态页面，所以我们需要一个方案来将我们的文档有组织有结构的生成html。\n手写是不可能的，这辈子都不可能的。\n翻了翻，大约流行的是这三个jekyll, hexo, hugo. 这三个都是比较完整的框架，内置server, 也就是说可以运行后在本地通过浏览器访问本地的网页，同样也支持各种插件安装。最后生成需要上传的页面\n简单比较    方案 语言 特点     jekyll Ruby 应该很老牌，github默认建git page时就推荐用这个。 应该各种插件之类很全。 编译速度慢一点   hexo Node 用node搞的，好像是台湾的达人弄的，所以中文文档丰富   hugo go 编译速度快。 看了看文档页，目测文档数量是hexo的两倍 —— 复杂    我本打算选用jekyll, 可以按照官方文档安装后运行报错， 搜了一下，应该是mac的m1芯片在调用sass的一个解析器时出错。对于这种错误，如果没有很快速的搜到解决方案，那就放弃，折腾起来太费时间\n——所以Jekylly被我放弃了。\n于是我拥抱了hugo\nhugo构建 很简单\n 将repo clone下来 按照hugo文档安装。 创建一个页面，运行hugo server -D ，即可在本地查看预览 推送上去就能访问了  突然发现我的这个guide很水。。。 😄😄😄😄\n其实最后一点不准确，推送上去是看不到刚才创建的文章的，甚至连网页都打不开，因为整个repo都变成了包含hugo的一整套库，git page是不认识的，记得吗，人家只认静态页面。\n我们推送的应该是hugo编译好的结果的文件。例如xxx.html/ xxx.js/ xxxx.cs\n这些文件在哪里呢？ 其实在public目录下，运行hugo 就会生成，因此我们要上传的其实是这个public文件夹。\n更进一步 参考hugo的部署文档，发现里面指导使用github的actions来发布。 关于github的actions, 可以参考这篇文章 简单的说，这个actions就类似jenkins, github提供了一些虚拟机环境，你可以通过配置脚本在执行一些操作。\n以我们发布文章来说，我们需要当提交整个repo后，github能够帮我们编译生成静态页面，然后将其放到我们git page的页面里。 这里再说一下，github为这类提供了一个专用分支，gh-page, 也就是说按照部署文档来最后我们可以看到repo多了一个gh-page分支，里面就是public的内容。\n使用github的actions很单间，就是在repo下创建一个.workflows目录，再放一个xx.yml，这个xx.yml就是配置文件。每次提交，github就会触发这个action\n万事具备，于是这篇文章就诞生了。\n","date":"2021-12-11","img":"","permalink":"/zh-cn/guide/use-hugo-with-github-page/","series":[],"tags":[""],"title":"Use Hugo With Github Page"},{"categories":null,"content":"你好，世界。\n这是一个新的开始，我相信明天总是很美好的。\n","date":"2021-12-09","img":"","permalink":"/zh-cn/posts/my-first-post/","series":null,"tags":null,"title":"My First Post"},{"categories":null,"content":" Tian Yuan\u0026rsquo;s husband and Pingping \u0026amp; Anan\u0026rsquo;s father. More than 10 years in software developing. Mainly in Java, Php, Js Plantyful experience in Lavarel, Spring, React. Others including Javafx, Android  ","date":"2021-12-09","img":"","permalink":"/zh-cn/about/","series":null,"tags":null,"title":"About"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/zh-cn/contact/","series":null,"tags":null,"title":"Contact Me"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/zh-cn/offline/","series":null,"tags":null,"title":"Offline"}]